import torch
from type_system import INT, STRING, Arrow, Type
import type_system
from Predictions.models import RulesPredictor, BigramsPredictor
from pcfg import PCFG
from typing import Callable, List, Tuple
from dsl import DSL
from program import Program
import experiment_helper
import shape as sh
import numpy as np

PENALITY_OUT_OF_BOUND = 5
PENALITY_SUPERPOSITION = 5

def make_program_checker_logo(dsl: DSL, examples) -> Callable[[Program, bool], bool]:
    def checker(prog: Program, use_cached_evaluator: bool) -> bool:
        if use_cached_evaluator:
            for i, example in enumerate(examples):
                input, output = example
                prog.eval(dsl, input, i)
                out = draw_all_shape() # Récupérer l'image
                if output != out:
                    return False
                clear_list_shape()
            return True
        else:
            for example in examples:
                input, output = example
                prog.eval(dsl, input, i)
                out = draw_all_shape()
                if output != out:
                    return False
                clear_list_shape()
            return True
    return checker

def loss_function_logo(listOfShape):
    valid = True
    score = 0

    if listOfShape == []:
        valid = False

    listShapeIn = []
    # En dehors du canvas
    for s in listOfShape:
        if 0 <= s.position[0] <= sh.IMG_WIDTH and 0 <= s.position[1] <= sh.IMG_HEIGHT:
            listShapeIn.append(s)
        else:
            score += PENALITY_OUT_OF_BOUND

    # Superposé parfaitement
    for i, s in enumerate(listShapeIn):
        for s2 in listShapeIn[(i+1):]:
            if s == s2 :
                score += PENALITY_SUPERPOSITION

    return (valid, score)

def evaluate_superposition_img(listOfShape):
    """
    This function is used to evaluate the number of shapes in the image generated by the list of shapes given as its argument

    listOfShape : a list of Shape object

    Return the difference between the number of shape expected in the image and the actual number of shape found 
    """
    nb_color_expected = len(listOfShape)
    img = sh.draw_all_shape_to_img(lShape=listOfShape, collision=True)
    img_array = np.asarray(img)

    uniques = np.unique(img_array.reshape(-1, img_array.shape[2]), axis=0)
    
    # We do not count black and white since they may be in the image by default
    nb_to_not_count = 0
    for i in uniques:
        if np.array_equal(i, [0,0,0]) or np.array_equal(i, [255,255,255]):
            nb_to_not_count += 1

    return nb_color_expected - (len(uniques) - nb_to_not_count)
